class PetriNet
types
	public Marking = map Place to nat;
instance variables
	public Places : set of Place := {};
	public Transitions : set of Transition := {};
	public InitialMarking : Marking  := {|->};
	public CurrentMarking : Marking := {|->};
	
	inv forall t in set Transitions & dom t.Inputs subset Places and
																		dom t.Outputs subset Places and
																		t.Resets subset Places and
																		t.Inhibitors subset Places;
	
operations



	-- Constructor for the Petri Net.
	-- @param places: the set of places in the net
	-- @param transitions: the set of transitions in the net
	-- @returns the petri net
	public PetriNet(places: set of Place, transitions: set of Transition) result : PetriNet == (
						Places := places;
						Transitions := transitions;
						InitialMarking := {|->};
						CurrentMarking := InitialMarking;
						
						return self;				
	)
	pre forall t in set Transitions & dom t.Inputs subset Places and
																		dom t.Outputs subset Places
	post result.Places = places and result.Transitions = transitions and 
								result.InitialMarking = {|->} and result.CurrentMarking = {|->};
					
								
								
	-- Checks if a transition is enabled at the time.
	-- @param t: the transition to check
	-- @returns true if the transition is enabled, false otherwise
	public transitionEnabled(t : Transition) result : bool == (
		dcl enabled: bool := true;
		
		for all i in set dom t.Inputs do (
			if CurrentMarking(i) < t.Inputs(i) then enabled := false;
		);
		
		for all i in set t.Inhibitors do (
			if CurrentMarking(i) > 0 then enabled := false;
		);
		
		return enabled;
	)
	pre t in set Transitions;
	
	
	
	-- Gets all enabled transitions in the net.
	-- @returns a set containing all enabled transitions at the time
	public getEnabled() result : set of Transition == (
		dcl enabledTrans: set of Transition := {};
		
		for all t in set Transitions do 
			if transitionEnabled(t) then enabledTrans := enabledTrans union {t};
			
		return enabledTrans;
	)
	post result subset Transitions and
				(forall t in set result & forall i in set dom t.Inputs & CurrentMarking(i) = t.Inputs(i)) and
				(forall t in set result & forall i in set t.Inhibitors & CurrentMarking(i) = 0);
	
	
	
	-- Resets the petri net marking to its initial marking.
	public reset() == (
		CurrentMarking := InitialMarking;
	)
	post CurrentMarking = InitialMarking;
	
	
	
	-- Triggers the selected transition if it's enabled.
	-- @param t: The transition to trigger.
	public fireTransition(t : Transition) == (
		if(transitionEnabled(t)) then (
			for all i in set dom t.Inputs do
				CurrentMarking := CurrentMarking ++ {i |-> CurrentMarking(i) - t.Inputs(i)};
		
			for all o in set dom t.Outputs do
				CurrentMarking := CurrentMarking ++ {o |-> CurrentMarking(o) + t.Outputs(o)};
				
			for all r in set t.Resets do
				CurrentMarking := CurrentMarking ++ {r |-> 0};
		);
	)
	pre t in set Transitions and 
				(forall i in set dom t.Inputs & CurrentMarking(i) = t.Inputs(i)) and
				(forall i in set t.Inhibitors & CurrentMarking(i) = 0)
	post (forall p in set dom t.Inputs & CurrentMarking(p) = CurrentMarking~(p) - t.Inputs(p)) and
			 (forall p in set dom t.Outputs & CurrentMarking(p) = CurrentMarking~(p) + t.Outputs(p));
			 
	
	
	public calculateReachabilityGraph() result : ReachabilityGraph == (
		dcl Graph : ReachabilityGraph := new ReachabilityGraph();
		dcl Work : seq of Marking := [InitialMarking];
		dcl M : Marking;
		dcl newM : Marking;
		dcl edge : Edge;
		dcl pn : PetriNet := new PetriNet(Places,Transitions);
		pn.InitialMarking := InitialMarking;
		
		Graph.Vertexes := {InitialMarking};
		Graph.Edges := {};
		Graph.InitialV := InitialMarking;
		
		while Work <> [] do (
			M := hd Work;
			Work := tl Work;
			
			pn.CurrentMarking := M;
			for all t in set pn.getEnabled() do (
				pn.fireTransition(t);
				newM := pn.CurrentMarking;
				if newM not in set Graph.Vertexes then (
					Graph.Vertexes := Graph.Vertexes union {newM};
					Work := Work ^ [newM];
				);
				
				edge := new Edge();
				edge.Origin := M;
				edge.Result := newM;
				edge.T := t;
				
				Graph.Edges := Graph.Edges union {edge};
			);
		);
		
		return Graph;
	)
	post (forall m in set result.Vertexes & dom m subset Places) and 
				result.InitialV = InitialMarking and
				(forall e in set result.Edges & dom e.Origin subset Places and dom e.Result subset Places and e.T in set Transitions);
	
	public isMarkingReachable(m : Marking) result : bool == (
		dcl Graph : ReachabilityGraph := calculateReachabilityGraph();
		if m in set Graph.Vertexes then return true;
		
		return false;
	)
	pre dom m subset Places;
	
	public getReachableMarkings() result : set of Marking == (
		dcl Graph : ReachabilityGraph := calculateReachabilityGraph();
		return Graph.Vertexes;
	)
	post forall m in set result & dom m subset Places;
	
	
functions
-- TODO Define functiones here
traces
-- TODO Define Combinatorial Test Traces here
end PetriNet